import pandas as pd
import json 
import logging
import pydicom

from damply import dirs
from pathlib import Path

def match_ann_to_image(idx_df: pd.DataFrame): 
    '''
    Takes the index file generated by MedImageTools and returns the pairs of annotation and image instances that match.
    Also logs which SRs do not have an imaging pair as well as duplicate SR ReferencedSeriesUIDs and imaging SeriesInstanceUIDs.

    Parameters 
    ----------
    idx_df: pd.DataFrame
        Contains the information found in the index.csv file 
    
    Returns 
    ----------
    matched_ann_image_df: pd.DataFrame 
        Contains the information about the matching annotation-image instances, where each row represents a patient's matched data
    '''
    cols = ["AnnPatientID", 
            "ImgPatientID",
            "AnnStudyInstanceUID",
            "ImgStudyInstanceUID", 
            "AnnReferencedSeriesUID",
            "ImgSeriesInstanceUID",  
            "ImgLocation", 
            "ImgSubSeries", 
            "ImgModality", 
            "AnnLocation", 
            "AnnSubSeries", 
            "AnnModality",
            "AnnSeriesInstanceUID"]
    
    matched_ann_image_df = pd.DataFrame(columns = cols)
    
    sr_df = idx_df[(idx_df["Modality"] == "SR")] 

    sr_ref_ser_UIDs = list()
    for ref_seriesUID in sr_df["ReferencedSeriesUID"].tolist(): 
        if ref_seriesUID in sr_ref_ser_UIDs: 
            continue
        
        dupe_img_seriesID = False

        sr_info = idx_df[(idx_df["Modality"] == "SR") & (idx_df["ReferencedSeriesUID"] == ref_seriesUID)].reset_index(drop = True)

        if sr_info.shape[0] > 1: 
            logger.info("SR ReferencedSeriesUID for Patient ID: %s has one or more duplicates. Relevant data below:", sr_info["PatientID"].values[0])
            logger.info(sr_info)

        matching_image = idx_df[(idx_df["Modality"] == "CT") & (idx_df["SeriesInstanceUID"] == ref_seriesUID)].reset_index(drop = True)
        if matching_image.shape[0] > 1:
            logger.debug("Imaging SeriesInstanceUID for Patient ID: %s has one or more duplicates. Relevant data below:", matching_image["PatientID"].values[0])
            logger.debug(matching_image)
            logger.debug(sr_info)
            dupe_img_seriesID = True

        elif matching_image.empty: 
            logger.info("No matching imaging SeriesInstanceUID for Patient ID: %s with SR ReferencedSeriesUID: %s", sr_info["PatientID"].values[0], ref_seriesUID)
            continue

        if dupe_img_seriesID: 
            img_subseries = "N/A"
        else: 
            img_subseries = matching_image["SubSeries"].values[0]

        for idx, row in sr_info.iterrows():  
            matched_info = [row["PatientID"],
                            matching_image["PatientID"].values[0], 
                            row["StudyInstanceUID"],
                            matching_image["StudyInstanceUID"].values[0],
                            row["ReferencedSeriesUID"],
                            matching_image["SeriesInstanceUID"].values[0],
                            matching_image["folder"].values[0], 
                            img_subseries, 
                            matching_image["Modality"].values[0],
                            row["folder"], 
                            row["SubSeries"], 
                            row["Modality"],
                            row["SeriesInstanceUID"]
                            ]
            matched_df = pd.DataFrame([matched_info], columns = cols)
            matched_ann_image_df = pd.concat([matched_ann_image_df, matched_df])

        sr_ref_ser_UIDs.append(ref_seriesUID)

    matched_ann_image_df = matched_ann_image_df.reset_index(drop = True)

    return matched_ann_image_df

def match_img_to_seg(idx_df: pd.DataFrame, 
                     matched_ann_img_df: pd.DataFrame): 
    '''
    Of the images that have a SRs, find the matching image and SEG/RTSTRUCT pair. 
    
    Parameters
    ----------
    idx_df: pd.DataFrame 
        Contains the information found in the index.csv file generated by MedImageTools
    matched_ann_img_df: pd.DataFrame 
        Contains the relevant information necessary to find an image and SEG/RTSTRUCT pair from the SeriesInstanceUIDs

    Returns 
    ----------
    matched_img_seg_df: pd.DataFrame 
        Each imaging-segmentation pair of matched information is represented in each row    
    '''
    cols = ["SegPatientID",
            "ImgPatientID",  
            "SegStudyInstanceUID", 
            "ImgStudyInstanceUID",
            "SegReferencedSeriesUID",
            "ImgSeriesInstanceUID",
            "ImgLocation", 
            "ImgSubSeries",
            "SegModality",
            "SegLocation", 
            "SegSubSeries", 
            "SegSeriesInstanceUID",
           ]
    
    matched_img_seg_df = pd.DataFrame(columns = cols)
    
    seg_df = idx_df[(idx_df["Modality"] == "RTSTRUCT") | (idx_df["Modality"] == "SEG")].reset_index(drop = True)

    #NOTE TO SELF: Need to add compatibility with having duplicate img_ser_UIDs, maybe do this by subseries? For now just ignoring. 
    img_ser_UIDs = list()
    for idx_img, row_img in matched_ann_img_df.iterrows(): 
        curr_img_ser_UID = row_img["ImgSeriesInstanceUID"]
        if curr_img_ser_UID in img_ser_UIDs:  #If already searched through this SeriesInstanceUID, skip. 
            continue
        matching_seg = seg_df[seg_df["ReferencedSeriesUID"] == curr_img_ser_UID].reset_index(drop = True) 
        if matching_seg.shape[0] > 1: 
            logger.info("Imaging SeriesInstanceUID: %s for Patient ID: %s has two or more segmentation ReferencedSeriesUID matches. Relevant data below: ", curr_img_ser_UID, row_img["ImgPatientID"])
            logger.info(matching_seg)
        
        for idx_seg, row_seg in matching_seg.iterrows(): 
            matched_info = [row_seg["PatientID"],
                            row_img["ImgPatientID"], 
                            row_seg["StudyInstanceUID"],
                            row_img["ImgStudyInstanceUID"],
                            row_seg["ReferencedSeriesUID"],
                            curr_img_ser_UID, 
                            row_img["ImgLocation"], 
                            row_img["ImgSubSeries"],
                            row_seg["Modality"],
                            row_seg["folder"], 
                            row_seg["SubSeries"], 
                            row_seg["SeriesInstanceUID"]
                            ]
            matched_df = pd.DataFrame([matched_info], columns = cols)
            matched_img_seg_df = pd.concat([matched_img_seg_df, matched_df])
        
        img_ser_UIDs.append(curr_img_ser_UID)

    matched_img_seg_df = matched_img_seg_df.reset_index(drop = True)
            
    return matched_img_seg_df

#This is for if the json file has all necessary information as of now.

def get_ann_measurements(ann_dicom_file_path: Path): 
    '''
    Scrapes the raw annotation DICOM file for information relating to long axis measurements. Logs all possible measurements. 
    Assumes all relevant data in the SR follows the same structure and depth and that all measurements correspond to relevant tumours.

    Paramters
    ---------
    ann_dicom_file_path: Path
        Path to SR file

    Returns 
    ---------
    tum_info_df: pd.DataFrame
        Contains information related to file and the long and short axis measurements
    '''
    cols = ["AnnSeriesInstanceUID", 
            "LongAxisMeasureType", 
            "LongAxisUnit", 
            "LongAxisMeasurement", 
            "LongAxisRefSOPUID", 
            "ShortAxisMeasureType", 
            "ShortAxisUnit", 
            "ShortAxisMeasurement", 
            "ShortAxisRefSOPUID"]
    
    tum_info_df = pd.DataFrame(columns = cols)
    dicom_data = pydicom.dcmread(ann_dicom_file_path)

    ann_seriesInstUID = dicom_data.SeriesInstanceUID
    parent_cont_seq = dicom_data.ContentSequence
    
    logger.info("Measurements being obtained for file: %s", ann_dicom_file_path)

    for cont_seq in range(len(parent_cont_seq[4]["ContentSequence"].value)): 
        measure_type_long = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][2]["ConceptNameCodeSequence"][0]["CodeMeaning"].value
        measure_unit_long = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][2]["MeasuredValueSequence"][0]["MeasurementUnitsCodeSequence"][0]["CodeValue"].value
        measurement_long = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][2]["MeasuredValueSequence"][0]["NumericValue"].value
        ref_SOPUID_long = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][2]["ContentSequence"][0]["ContentSequence"][0]["ReferencedSOPSequence"][0]["ReferencedSOPInstanceUID"].value

        logger.info("Long axis measurement of type %s and units %s has been obtained.", measure_type_long, measure_unit_long)
        logger.info("Long axis easurement value: %s", measurement_long)
        logger.info("Long axis corresponding ReferencedSOPUID: %s", ref_SOPUID_long)

        measure_type_short = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][3]["ConceptNameCodeSequence"][0]["CodeMeaning"].value
        measure_unit_short = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][3]["MeasuredValueSequence"][0]["MeasurementUnitsCodeSequence"][0]["CodeValue"].value
        measurement_short = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][3]["MeasuredValueSequence"][0]["NumericValue"].value
        ref_SOPUID_short = parent_cont_seq[4]["ContentSequence"][cont_seq]["ContentSequence"][3]["ContentSequence"][0]["ContentSequence"][0]["ReferencedSOPSequence"][0]["ReferencedSOPInstanceUID"].value

        logger.info("Short axis measurement of type %s and units %s has been obtained.", measure_type_short, measure_unit_short)
        logger.info("Short axis measurement value: %s", measurement_short)
        logger.info("Short axis corresponding ReferencedSOPUID: %s", ref_SOPUID_short)

        #Check to make sure long and short axis measurements were taken on same slice. 
        if ref_SOPUID_long != ref_SOPUID_short: 
            logger.debug("Long and short axis measurements for SeriesInstanceUID %s not taken on the same slice")
            logger.debug("Long axis RefSOPUID: %s", ref_SOPUID_long)
            logger.debug("Short axis RefSOPUID: %s", ref_SOPUID_short)

        curr_tum_info = [ann_seriesInstUID, 
                         measure_type_long, 
                         measure_unit_long,
                         measurement_long, 
                         ref_SOPUID_long, 
                         measure_type_short,
                         measure_unit_short,
                         measurement_short, 
                         ref_SOPUID_short]
        
        curr_tum_df = pd.DataFrame([curr_tum_info], columns = cols)
        
        if tum_info_df.empty: 
            tum_info_df = curr_tum_df
        else:
            tum_info_df = pd.concat([tum_info_df, curr_tum_df])

    return tum_info_df

def get_rtstruct_SOPUIDs(rtstruct_dicom_path: Path):
    '''
    Gathers all referencedSOPInstanceUIDs (slices) for the given segmentation. 
    Assumes only one DICOM file per folder and one segmentation per DICOM file. 

    Parameters
    ----------
    rtstruct_dicom_path: Path   
        Path to RTSTRUCT folder

    Returns
    rtstruct_SOPUIDs: list 
        Contains all of the mentioned slice IDs in the given RTSTRUCT file. 
    '''

    dicom_data = pydicom.dcmread(rtstruct_dicom_path)
    
    parent_sequence = dicom_data.ReferencedFrameOfReferenceSequence
    seg_seq = parent_sequence[0]["RTReferencedStudySequence"][0]["RTReferencedSeriesSequence"][0]["ContourImageSequence"]

    rtstruct_SOPUIDs = list()
    for element in range(len(seg_seq.value)): 
        if "ReferencedSOPInstanceUID" in seg_seq[element]: 
            curr_SOPUID = seg_seq[element]["ReferencedSOPInstanceUID"].value
            rtstruct_SOPUIDs.append(curr_SOPUID)

    return rtstruct_SOPUIDs

def match_ann_to_seg(match_ann_img_df: pd.DataFrame, 
                     match_img_seg_df: pd.DataFrame, 
                     dicom_info_dict: dict, 
                     ann_dicom_path: Path, 
                     seg_dicom_path: Path):
    '''
    Using the information from the previous two functions above, find which segmentation the annotation belongs to
    via checking if the annotation slice is referenced in the segmentation list of slices. 
    Also logs if the segmentation slices overlap with other segmentations and if annotations can belong in more than
    one segmentation. 

    Parameters 
    ----------
    match_ann_img_df: pd.DataFrame
        Contains the information about the matching annotation-image instances, where each row represents a patient's matched data
    match_img_seg_df: pd.DataFrame
        Each imaging-segmentation pair of matched information is represented in each row
    dicom_info_dict: dict 
        Contains the DICOM information found in the med-imagetools generated crawl_db.json file. 
    ann_dicom_path: Path 
        Path to folder holding all raw annotation DICOM data
    seg_dicom_path: Path 
        Path to folder holding all raw SEG/RTSTRUCT DICOM data

    Returns
    ----------
    match_info_summary: pd.DataFrame 
        Contains the SEG or RTSTRUCT, SR, and imaging paired information. 
    no_match_info_summary: pd.DataFrame
        Contains the information for annotations that do not have segmentation matches. Segmentation info left blank. 
    '''
    cols = ["PatientID", 
            "StudyInstanceUID", 
            "ImgSeriesInstanceUID", 
            "AnnReferencedSeriesUID", 
            "SegReferencedSeriesUID", 
            "AnnSeriesInstanceUID", 
            "SegSeriesInstanceUIDs", 
            "AnnReferencedSOPUID", 
            "AnnLongAxisLength", 
            "AnnLongAxisMeasureType", 
            "AnnLongAxisMeasureUnit",
            "AnnShortAxisLength", 
            "AnnShortAxisMeasureType", 
            "AnnShortAxisMeasureUnit",
            "ImgModality", 
            "AnnModality", 
            "SegModality", 
            "ImgSubSeries", 
            "ImgLocation", 
            "AnnLocation",
            "AnnFilename", 
            "SegLocation"       
           ]
    
    match_info_summary = pd.DataFrame(columns = cols) 
    no_match_info_summary = pd.DataFrame(columns = cols)

    for ann_seriesInstUID in match_ann_img_df["AnnSeriesInstanceUID"]:
        img_ann_info = match_ann_img_df[match_ann_img_df["AnnSeriesInstanceUID"] == ann_seriesInstUID]
        ann_series_info = dicom_info_dict[ann_seriesInstUID]
        ann_dicom_info = ann_series_info["1"] #Assumes that all SRs have SubSeries "1" and only "1"

        ann_refSOPUIDs = ann_dicom_info["ReferencedSOPUIDs"]
        if len(ann_refSOPUIDs) > 1: 
            logger.debug("More than one slice referenced in annotation SeriesInstanceUID: %s", ann_seriesInstUID)
            logger.debug("Slices listed: ") 
            logger.debug(ann_refSOPUIDs)

        #Get RECIST measurement and check though all measurements if multiple
        inst = list(ann_dicom_info["instances"])
        filename = ann_dicom_info["instances"][inst[0]]
        logger.info("Corresponding annotation file for below measurements: %s", filename) #Assumes only one instance for each SR
        
        ann_file_path = ann_dicom_path / filename
        tum_measurements = get_ann_measurements(ann_file_path)
        
        ann_refSeriesUID = ann_dicom_info["ReferencedSeriesUID"]
        
        for refSOPUID in ann_refSOPUIDs: 
            curr_measurements = tum_measurements[tum_measurements["LongAxisRefSOPUID"] == refSOPUID]
            if curr_measurements.shape[0] > 1: 
                logger.debug("Multiple long axis measurements on the same slice") #This should never happen unless there is overlap of segmentations 
                continue
            
            #Handling duplicate imaging SeriesInstanceUIDs (for ones with multiple SubSeries) 
            if img_ann_info["ImgSubSeries"].values[0] == "N/A": 
                logger.info("Finding correct imaging subseries.")
                img_ser_instUID = img_ann_info["ImgSeriesInstanceUID"].values[0]
                image_series_info = dicom_info_dict[img_ser_instUID]
                for subseries in image_series_info: 
                    image_dicom_info = image_series_info[str(subseries)]
                    img_inst = list(image_dicom_info['instances'])
                    if refSOPUID in img_inst: 
                        img_subseries = subseries
            else: 
                img_subseries = img_ann_info["ImgSubSeries"].values[0]

            match_seg_tests = match_img_seg_df[match_img_seg_df["SegReferencedSeriesUID"] == ann_refSeriesUID] 

            potential_seg_matches = list()

            for seg_seriesInstUID in match_seg_tests["SegSeriesInstanceUID"]: 
                curr_info = match_seg_tests[match_seg_tests["SegSeriesInstanceUID"] == seg_seriesInstUID]
                seg_series_info = dicom_info_dict[seg_seriesInstUID]
                seg_dicom_info = seg_series_info["1"] #Assumes the same as SRs subseries

                if curr_info["SegModality"].values[0] == "SEG": 
                    seg_refSOPUIDs = seg_dicom_info["ReferencedSOPUIDs"]
                    if len(list(seg_dicom_info["instances"])) > 1: 
                        logger.debug("More than one segmentation found in the segmentation file for Patient ID: %s. Please double check this. Relevant data below:", seg_dicom_info["PatientID"])
                        logger.debug(seg_refSOPUIDs)
                        continue
                    
                elif curr_info["SegModality"].values[0] == "RTSTRUCT": 
                    seg_partial_path = seg_dicom_info["folder"]
                    seg_dicom_file = seg_dicom_path / seg_partial_path / "1.dcm" #Assuming all segmentation files are labelled as "1.dcm"
                    seg_refSOPUIDs = get_rtstruct_SOPUIDs(seg_dicom_file)

                else: 
                    logger.error("Segmentation modality %s is currently not supported. Skipping segmentation", curr_info["SegModality"])

                if refSOPUID in seg_refSOPUIDs: 
                    potential_seg_matches.append(seg_dicom_info["SeriesInstanceUID"])

            if len(potential_seg_matches) > 1: 
                logger.debug("Annotation-segmentation matching indeterminant for annotation SeriesInstanceUID: %s. Annotation within multiple segmentation slices.", ann_refSeriesUID)
                logger.debug("Potential segmentation matches for %s: %s", ann_refSeriesUID, potential_seg_matches)
            elif len(potential_seg_matches) < 1: 
                logger.debug("No segmentation match found for annotation SeriesInstanceUID: %s with ReferencedSOPUID: %s", ann_seriesInstUID, refSOPUID)
                no_matched_info = [ann_dicom_info["PatientID"], 
                            ann_dicom_info["StudyInstanceUID"], 
                            img_ann_info["ImgSeriesInstanceUID"].values[0], 
                            ann_refSeriesUID,  
                            seg_dicom_info["ReferencedSeriesUID"], #Assumes that all potential seg matches have the same ref image
                            ann_dicom_info["SeriesInstanceUID"], 
                            potential_seg_matches, 
                            refSOPUID, 
                            curr_measurements["LongAxisMeasurement"].values[0],
                            curr_measurements["LongAxisMeasureType"].values[0], 
                            curr_measurements["LongAxisUnit"].values[0],
                            curr_measurements["ShortAxisMeasurement"].values[0], 
                            curr_measurements["ShortAxisMeasureType"].values[0], 
                            curr_measurements["ShortAxisUnit"].values[0],
                            img_ann_info["ImgModality"].values[0], 
                            ann_dicom_info["Modality"], 
                            seg_dicom_info["Modality"],
                            img_subseries, 
                            img_ann_info["ImgLocation"].values[0], 
                            img_ann_info["AnnLocation"].values[0],
                            filename,
                            None]
                
                no_match_df = pd.DataFrame([no_matched_info], columns = cols)
                if no_match_info_summary.empty: 
                    no_match_info_summary = no_match_df
                else: 
                    no_match_info_summary = pd.concat([no_match_info_summary, no_match_df])
                continue 

            potential_seg_locations = list()
            for seg_match in potential_seg_matches: 
                curr_seg_info = match_img_seg_df[match_img_seg_df["SegSeriesInstanceUID"] == seg_match]
                curr_seg = curr_seg_info["SegLocation"].values.tolist()
                potential_seg_locations.append(curr_seg)

            matched_info = [ann_dicom_info["PatientID"], 
                            ann_dicom_info["StudyInstanceUID"], 
                            img_ann_info["ImgSeriesInstanceUID"].values[0], 
                            ann_refSeriesUID,  
                            seg_dicom_info["ReferencedSeriesUID"], #Assumes that all potential seg matches have the same ref image
                            ann_dicom_info["SeriesInstanceUID"], 
                            potential_seg_matches, 
                            refSOPUID, 
                            curr_measurements["LongAxisMeasurement"].values[0],
                            curr_measurements["LongAxisMeasureType"].values[0], 
                            curr_measurements["LongAxisUnit"].values[0],
                            curr_measurements["ShortAxisMeasurement"].values[0], 
                            curr_measurements["ShortAxisMeasureType"].values[0], 
                            curr_measurements["ShortAxisUnit"].values[0],
                            img_ann_info["ImgModality"].values[0], 
                            ann_dicom_info["Modality"], 
                            seg_dicom_info["Modality"],
                            img_subseries, 
                            img_ann_info["ImgLocation"].values[0], 
                            img_ann_info["AnnLocation"].values[0],
                            filename,
                            potential_seg_locations
                        ]
        
            match_info_df = pd.DataFrame([matched_info], columns = cols)

            if match_info_summary.empty:
                match_info_summary = match_info_df
            else:
                match_info_summary = pd.concat([match_info_summary, match_info_df])

    return match_info_summary, no_match_info_summary

if __name__ == '__main__': 
    logger = logging.getLogger(__name__)
    logging.basicConfig(filename='/home/bhkuser/bhklab/kaitlyn/aaura_paper0/logs/match_no_match_ann_img_seg_NSCLC.log', encoding='utf-8', level=logging.DEBUG)

    idx_path = dirs.RAWDATA / "Lung/TCIA_NSCLC-Radiogenomics/.imgtools/images/index.csv"
    dicom_data_path = dirs.RAWDATA / "Lung/TCIA_NSCLC-Radiogenomics/.imgtools/images/crawl_db.json"
    ann_data_path = dirs.RAWDATA / "Lung/TCIA_NSCLC-Radiogenomics/images/annotations/NSCLC-Radiogenomics"
    seg_data_path = dirs.RAWDATA / "/Lung/TCIA_NSCLC-Radiogenomics"
    out_path = export_path = Path("/home/bhkuser/bhklab/kaitlyn/aaura_paper0/workflow/testing")

    index_df = pd.read_csv(idx_path)

    matched_ann_img_df = match_ann_to_image(index_df) 
    # matched_ann_img_df.to_csv(out_path / "matching_ann_to_img_CCRCC.csv", index = False)

    matched_img_seg_df = match_img_to_seg(index_df, matched_ann_img_df) 
    # matched_img_seg_df.to_csv(out_path / "matching_img_to_seg_CCRCC.csv", index = False)

    with open(dicom_data_path, 'r') as file: 
        dicom_data_json = file.read()
        dicom_data_dict = json.loads(dicom_data_json)

        matched_ann_seg, no_match_ann_seg = match_ann_to_seg(matched_ann_img_df, matched_img_seg_df, dicom_data_dict, ann_data_path, seg_data_path)
        matched_ann_seg.to_csv(out_path / "matching_ann_to_seg_NSCLC.csv", index = False)
        no_match_ann_seg.to_csv(out_path / "no_match_anns_NSCLC.csv", index = False)

        file.close()